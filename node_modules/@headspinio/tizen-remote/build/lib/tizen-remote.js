"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TizenRemote_instances, _TizenRemote_host, _TizenRemote_port, _TizenRemote_id, _TizenRemote_token, _TizenRemote_ssl, _TizenRemote_ws, _TizenRemote_handshakeRetries, _TizenRemote_autoReconnect, _TizenRemote_handshakeTimeout, _TizenRemote_debugger, _TizenRemote_tokenTimeout, _TizenRemote_listeners, _TizenRemote_tokenCache, _TizenRemote_tokenSupportCache, _TizenRemote_persistToken, _TizenRemote_strongbox, _TizenRemote_debug, _TizenRemote_url_get, _TizenRemote_getTokenCache, _TizenRemote_listenWs, _TizenRemote_onWs, _TizenRemote_onceWs, _TizenRemote_offWs, _TizenRemote_debugListener, _TizenRemote_updateTokenListener, _TizenRemote_closeListener;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TizenRemote = exports.WsEvent = exports.KeyCmd = exports.Event = exports.constants = exports.BadCode = exports.Keys = void 0;
const strongbox_1 = require("@appium/strongbox");
const env_1 = require("@humanwhocodes/env");
const debug_1 = __importDefault(require("debug"));
const delay_1 = __importDefault(require("delay"));
const lodash_1 = __importDefault(require("lodash"));
const node_events_1 = require("node:events");
const node_util_1 = require("node:util");
const p_retry_1 = __importDefault(require("p-retry"));
const ws_1 = __importDefault(require("ws"));
const command_1 = require("./command");
const keys_1 = require("./keys");
Object.defineProperty(exports, "Keys", { enumerable: true, get: function () { return keys_1.Keys; } });
const got_1 = __importDefault(require("got"));
const format = lodash_1.default.partial(node_util_1.formatWithOptions, { depth: null, colors: true });
/**
 * This tricks TS into typing the events and associated data in {@linkcode TizenRemote}
 *
 * See {@linkcode TizenRemoteInstance}
 * @internal
 */
function createdTypedEmitterClass() {
    return /** @type { {new(): TizenRemoteInstance} } */ ( /** @type {unknown} */(node_events_1.EventEmitter));
}
/**
 * Codes received when a connection to a WSS fails.
 * @see https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1
 * @group Constants
 */
exports.BadCode = ({
    1002: 'Protocol Error',
    1003: 'Invalid Data Type',
    1005: 'No Status',
    1006: 'Abnormal Closure',
    1007: 'Invalid Message Data Type',
    1008: 'Policy Violation',
    1009: 'Message Too Big',
    1010: 'Mandatory Extension Missing',
    1011: 'Unexpected Condition',
    1015: 'TLS Handshake Failure',
});
/**
 * Constant values, defaults, etc.
 * @group Constants
 */
exports.constants = ({
    /**
     * Path on the Tizen device to the WS server
     */
    API_PATH_V2: '/api/v2/channels/samsung.remote.control',
    /**
     * Timeout for initial handshake to the Tizen device (in ms)
     */
    DEFAULT_HANDSHAKE_TIMEOUT: 1000,
    /**
     * Number of times to retry a failed connection
     */
    DEFAULT_HANDSHAKE_RETRIES: 2,
    /**
     * If `true`, automatically attempt to reconnect when connection fails
     */
    DEFAULT_AUTO_RECONNECT: true,
    /**
     * Wait this long to get a new token (in ms).
     */
    DEFAULT_TOKEN_TIMEOUT: 40000,
    /**
     * Default port on the Tizen device to connect to
     */
    DEFAULT_PORT: 8002,
    /**
     * Use SSL when connecting to the Tizen device
     */
    DEFAULT_SSL: true,
    /**
     * Default client name (before encoding to base64)
     */
    DEFAULT_NAME: 'Appium',
    /**
     * The `Method` property in msg payload when sending commands to the Tizen device
     */
    COMMAND_METHOD: 'ms.remote.control',
    /**
     * The `timeout` property in msg payload when sending commands to the Tizen device
     *
     * This could occur when the given api token was valid but needs a fresh token?
     */
    COMMAND_TIMEOUT: 'ms.channel.timeOut',
    /**
     * The `Event` property in msg payload when requesting a token
     *
     * Likewise the `event` property in a message payload when receiving the new token
     */
    TOKEN_EVENT: 'ms.channel.connect',
    /**
     * I don't know, but it goes in the command payload and it's always `'false'`.
     */
    COMMAND_PARAMS_OPTION: 'false',
    /**
     * Value of the `TypeOfRemote` property in the command payload
     */
    COMMAND_PARAMS_TYPE_OF_REMOTE: 'SendRemoteKey',
    /**
     * Basename of the token cache file
     */
    TOKEN_CACHE_BASENAME: 'token-cache',
    /**
     * Lockfile filename
     */
    TOKEN_CACHE_LOCKFILE_NAME: 'token-cache.lock',
    /**
     * Default value of `persistToken` option
     */
    DEFAULT_PERSIST_TOKEN: true,
    /**
     * Namespace for various usages
     */
    NS: 'tizen-remote',
});
/**
 * Events emitted by {@linkcode TizenRemote}.
 * @event
 */
exports.Event = ({
    CONNECT: 'connect',
    CONNECTING: 'connecting',
    DISCONNECT: 'disconnect',
    DISCONNECTING: 'disconnecting',
    ERROR: 'error',
    RETRY: 'retry',
    TOKEN: 'token',
    SENT: 'sent',
});
/**
 * Valid types of keypresses which can be sent in the msg command payload
 * @group Constants
 */
exports.KeyCmd = ({
    PRESS: 'Press',
    CLICK: 'Click',
    RELEASE: 'Release',
});
/**
 * Events emitted by a {@linkcode WebSocket}.
 * @enum {string}
 * @event
 */
exports.WsEvent = ({
    CONNECT: 'connect',
    CLOSE: 'close',
    ERROR: 'error',
    OPEN: 'open',
    MESSAGE: 'message',
});
/**
 * Type guard for {@link BadCode}.
 * @internal
 * @param {any} code
 * @returns {code is keyof BadCode}
 */
function isKnownBadCode(code) {
    return code in exports.BadCode;
}
/**
 * Type guard for incoming messages
 * @internal
 * @param {any} msg
 * @returns {msg is NewTokenMessage}
 */
function isTokenMessage(msg) {
    return Boolean(msg?.event === exports.constants.TOKEN_EVENT && msg?.data?.token);
}
/**
 * Type guard for incoming messages
 * @internal
 * @param {any} msg
 * @returns {msg is NewTokenMessage}
 */
function isCommandTimeout(msg) {
    return Boolean(msg?.event === exports.constants.COMMAND_TIMEOUT);
}
/**
 * Represents a connection to a Tizen web socket server.
 */
class TizenRemote extends createdTypedEmitterClass() {
    /**
     * @param {string} host - IP or hostname of the Tizen device
     * @param {TizenRemoteOptions} [opts]
     */
    constructor(host, opts = {}) {
        super();
        _TizenRemote_instances.add(this);
        /**
         * IP or hostname of the Tizen device
         * @type {string}
         */
        _TizenRemote_host.set(this, void 0);
        /**
         * Websocket port on Tizen device
         * @type {number}
         * @defaultValue See {@linkcode constants.DEFAULT_PORT}
         */
        _TizenRemote_port.set(this, void 0);
        /**
         * Client identifier; a base64-encoded string of the `host`.
         *
         * This is used in communication with the device.
         *
         * @type {string}
         */
        _TizenRemote_id.set(this, void 0);
        /**
         * Super secret access token.
         *
         * Typically this is a `string` of eight (8) integers.  If `undefined`, we will either retrieve it from the
         * environment or request one from the Tizen device.
         * @type {string|undefined}
         */
        _TizenRemote_token.set(this, void 0);
        /**
         * Use SSL?
         *
         * If the port is `8002`, this will be automatically set to `true`.
         * @type {boolean}
         * @defaultValue See {@linkcode constants.DEFAULT_SSL}
         */
        _TizenRemote_ssl.set(this, void 0);
        /**
         * {@linkcode WebSocket} instance
         * @type {WebSocket|undefined}
         */
        _TizenRemote_ws.set(this, void 0);
        /**
         * Number of times to retry connection/handshake
         * @type {number}
         * @defaultValue See {@linkcode constants.DEFAULT_HANDSHAKE_RETRIES}
         */
        _TizenRemote_handshakeRetries.set(this, void 0);
        /**
         * Whether or not to automatically reconnect when disconnected unexpectedly
         * @type {boolean}
         * @defaultValue See {@linkcode constants.DEFAULT_AUTO_RECONNECT}
         */
        _TizenRemote_autoReconnect.set(this, void 0);
        /**
         * How long to wait for a handshake to complete
         * @type {number}
         * @defaultValue See {@linkcode constants.DEFAULT_HANDSHAKE_TIMEOUT}
         */
        _TizenRemote_handshakeTimeout.set(this, void 0);
        /**
         * It's `debug`
         * @type {debug.Debugger}
         */
        _TizenRemote_debugger.set(this, void 0);
        /**
         * How long to wait to receive a token from the Tizen device
         * @type {number}
         * @defaultValue See {@linkcode constants.DEFAULT_TOKEN_TIMEOUT}
         */
        _TizenRemote_tokenTimeout.set(this, void 0);
        /**
         * Tracks listeners that we've added to the {@linkcode WebSocket} instance.
         *
         * We can remove them later to avoid leaking EE listeners.
         * @type {Map<WsEvent,Set<(...args: any[]) => void>>}
         */
        _TizenRemote_listeners.set(this, new Map());
        /**
         * Token cache object.
         *
         * Will remain `undefined` if token persistence is disabled
         * @type {import('@appium/strongbox').Item<string>|undefined}
         */
        _TizenRemote_tokenCache.set(this, void 0);
        /**
         * If the target device supports token.
         * @type {boolean | undefined}
         */
        _TizenRemote_tokenSupportCache.set(this, void 0);
        /**
         * Whether or not to persist tokens to the cache
         * @type {boolean}
         */
        _TizenRemote_persistToken.set(this, void 0);
        /**
         * Store for the token
         * @type {import('@appium/strongbox').Strongbox}
         */
        _TizenRemote_strongbox.set(this, void 0);
        if (!host) {
            throw new TypeError('"host" parameter is required');
        }
        const env = new env_1.Env();
        //  The strongbox suffix is default value, "-nodejs". Please do not modify it.
        __classPrivateFieldSet(this, _TizenRemote_strongbox, (0, strongbox_1.strongbox)(exports.constants.NS), "f");
        __classPrivateFieldSet(this, _TizenRemote_host, host, "f");
        __classPrivateFieldSet(this, _TizenRemote_port, Number(opts.port ?? exports.constants.DEFAULT_PORT), "f");
        __classPrivateFieldSet(this, _TizenRemote_persistToken, Boolean(opts.persistToken ?? exports.constants.DEFAULT_PERSIST_TOKEN), "f");
        // note: if this is unset, we will attempt to get a token from the fs cache,
        // and if _that_ fails, we'll go ahead and ask the device for one.
        __classPrivateFieldSet(this, _TizenRemote_token, opts.token ?? env.get('TIZEN_REMOTE_TOKEN'), "f");
        __classPrivateFieldSet(this, _TizenRemote_id, Buffer.from(__classPrivateFieldGet(this, _TizenRemote_host, "f")).toString('base64'), "f");
        if (opts.debug) {
            debug_1.default.enable(`${exports.constants.NS}*`);
        }
        __classPrivateFieldSet(this, _TizenRemote_debugger, (0, debug_1.default)(`${exports.constants.NS} [${__classPrivateFieldGet(this, _TizenRemote_host, "f")}]`), "f");
        // automatically set ssl flag if port is 8002 and no `ssl` opt is explicitly set
        __classPrivateFieldSet(this, _TizenRemote_ssl, opts.ssl !== undefined ? Boolean(opts.ssl) : __classPrivateFieldGet(this, _TizenRemote_port, "f") === 8002, "f");
        __classPrivateFieldSet(this, _TizenRemote_autoReconnect, opts.autoReconnect !== undefined
            ? Boolean(opts.autoReconnect)
            : exports.constants.DEFAULT_AUTO_RECONNECT, "f");
        __classPrivateFieldSet(this, _TizenRemote_handshakeTimeout, opts.handshakeTimeout ?? exports.constants.DEFAULT_HANDSHAKE_TIMEOUT, "f");
        __classPrivateFieldSet(this, _TizenRemote_handshakeRetries, opts.handshakeRetries ?? exports.constants.DEFAULT_HANDSHAKE_RETRIES, "f");
        __classPrivateFieldSet(this, _TizenRemote_tokenTimeout, opts.tokenTimeout ?? exports.constants.DEFAULT_TOKEN_TIMEOUT, "f");
        __classPrivateFieldSet(this, _TizenRemote_tokenSupportCache, undefined, "f");
    }
    /**
     * Just returns the client name (which is a base64-encoded string).
     */
    get base64Name() {
        return __classPrivateFieldGet(this, _TizenRemote_id, "f");
    }
    /**
     * Computed URL of the Tizen device's websocket endpoint (as a string)
     */
    get url() {
        return __classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get).toString();
    }
    /**
     * Return True if the target device has 'TokenAuthSupport' param for the api/v2 endpoint.
     * No 'TokenAuthSupport' indicates the device does not require "token".
     * @returns {Promise<boolean>}
     */
    async isTokenSupportedDevice() {
        if (lodash_1.default.isBoolean(__classPrivateFieldGet(this, _TizenRemote_tokenSupportCache, "f"))) {
            return __classPrivateFieldGet(this, _TizenRemote_tokenSupportCache, "f");
        }
        try {
            const deviceData = await got_1.default.get(`http://${__classPrivateFieldGet(this, _TizenRemote_host, "f")}:8001/api/v2/`).json();
            __classPrivateFieldSet(this, _TizenRemote_tokenSupportCache, this._getDeviceSupportsTokens(deviceData) === 'true', "f");
            return __classPrivateFieldGet(this, _TizenRemote_tokenSupportCache, "f");
        }
        catch {
            // defaults to true for newer TVs.
            return true;
        }
    }
    /**
     * Private. Accessible for testing
     * @param {any} jsonBody
     * @returns {'true'|'false'|undefined}
     */
    _getDeviceSupportsTokens(jsonBody) {
        return jsonBody?.device?.TokenAuthSupport;
    }
    /**
     * Unsets token.
     *
     * If token cache persistence is enabled, this will remove it from the cache as well.
     */
    async unsetToken() {
        if (__classPrivateFieldGet(this, _TizenRemote_persistToken, "f")) {
            const cache = await __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_getTokenCache).call(this);
            await cache.clear();
        }
        __classPrivateFieldSet(this, _TizenRemote_token, undefined, "f");
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Unset token for host %s', __classPrivateFieldGet(this, _TizenRemote_host, "f"));
    }
    /**
     * Resolves `true` if a token is set or the cache contains a token
     * @returns {Promise<boolean>}
     */
    async hasToken() {
        let result = false;
        if (__classPrivateFieldGet(this, _TizenRemote_token, "f")) {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Token is set (%s)', __classPrivateFieldGet(this, _TizenRemote_token, "f"));
            result = true;
        }
        else if (__classPrivateFieldGet(this, _TizenRemote_persistToken, "f")) {
            const cache = await __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_getTokenCache).call(this);
            result = Boolean(cache.value);
            if (result) {
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Found token in cache (%s)', cache.value);
            }
        }
        if (!result) {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'No token found in memory or cache');
        }
        return result;
    }
    /**
     * Reads token (if available) from the token cache in the filesystem
     *
     * If `#persistToken` is false, this will _always_ return `undefined`.
     * @returns {Promise<string|undefined>}
     */
    async readToken() {
        if (__classPrivateFieldGet(this, _TizenRemote_persistToken, "f")) {
            const cache = await __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_getTokenCache).call(this);
            return await cache.read();
        }
    }
    /**
     * Writes token to the token cache in the filesystem.
     *
     * If `#persistToken` is false, this will _never_ write to the cache.
     * @param {string} token
     * @returns {Promise<void>}
     */
    async writeToken(token) {
        if (__classPrivateFieldGet(this, _TizenRemote_persistToken, "f")) {
            const cache = await __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_getTokenCache).call(this);
            await cache.write(token);
        }
        __classPrivateFieldSet(this, _TizenRemote_token, token, "f");
    }
    /**
     * Send JSON-serializable data to the Tizen web socket server.
     *
     * This is low-level, and you probably want something else.
     * @param {any} data
     * @param {NoConnectOption & NoTokenOption} opts
     * @returns {Promise<void>}
     */
    async send(data, { noConnect = false, noToken = false } = {}) {
        /** @type {string} */
        let payload;
        if (!__classPrivateFieldGet(this, _TizenRemote_ws, "f")) {
            if (noConnect) {
                try {
                    payload = JSON.stringify(data);
                }
                catch {
                    payload = '(not serializable)';
                }
                throw new Error(`Disconnected; cannot send message: ${payload}`);
            }
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Disconnected when attempting to send; attempting connection...');
            // connect() assigns this.#ws if it was successful, so we
            // don't need to do so here.
            await this.connect({ noToken });
        }
        try {
            payload = JSON.stringify(data);
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Sending: %O', data);
        }
        catch (err) {
            const error = /** @type {TypeError} */ (err);
            throw new TypeError(`Cannot serialize data to JSON: ${error.message}`);
        }
        const send = /** @type {(data: any) => Promise<void>} */ ((0, node_util_1.promisify)(/** @type {WebSocket} */ (__classPrivateFieldGet(this, _TizenRemote_ws, "f")).send).bind(__classPrivateFieldGet(this, _TizenRemote_ws, "f")));
        await send(payload);
        this.emit(exports.Event.SENT, payload);
    }
    /**
     * Send JSON-serializable data to the Tizen web socket server.
     *
     * This is low-level, and you probably want something else.
     * @template T
     * @param {string} channel
     * @param {any} data
     * @param {SendRequestOptions} opts
     * @returns {Promise<T>}
     */
    async sendRequest(channel, data, { noConnect = false, noToken = false, timeout } = {}) {
        /** @type {string} */
        let payload;
        /** @type {WebSocket} */
        let ws;
        if (__classPrivateFieldGet(this, _TizenRemote_ws, "f")) {
            ws = __classPrivateFieldGet(this, _TizenRemote_ws, "f");
        }
        else {
            if (noConnect) {
                throw new Error(`Disconnected; cannot send message: ${data}`);
            }
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Not connected; attempting connection...');
            ws = await this.connect({ noToken });
        }
        try {
            payload = JSON.stringify(data);
        }
        catch (err) {
            throw new Error(`Unable to serialize data to JSON: ${ /** @type {Error} */(err).message}`);
        }
        const send = /** @type {(data: any) => Promise<void>} */ ((0, node_util_1.promisify)(ws.send).bind(__classPrivateFieldGet(this, _TizenRemote_ws, "f")));
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Sending request on channel %s: %O', channel, data);
        await send(payload);
        return await new Promise((resolve, reject) => {
            /** @type {NodeJS.Timeout|undefined} */
            let timer;
            if (timeout !== undefined) {
                timer = setTimeout(() => {
                    __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_offWs).call(this, exports.WsEvent.MESSAGE, listener);
                    reject(new Error(`Did not receive token in ${timeout}ms`));
                }, timeout);
            }
            /** @param {import('ws').RawData} data */
            const listener = (data) => {
                try {
                    const resData = JSON.parse(data.toString());
                    if (resData.event === channel) {
                        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_offWs).call(this, exports.WsEvent.MESSAGE, listener);
                        clearTimeout(timer);
                        resolve(resData);
                    }
                }
                catch {
                    __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Failed to parse JSON from raw response: %O', data);
                    // if we can't parse the data, it's not something we're interested in
                }
            };
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onWs).call(this, exports.WsEvent.MESSAGE, listener);
        });
    }
    /**
     * Execute a "click" on the remote
     * @param {RcKeyCode} key
     */
    async click(key) {
        await this.send(new command_1.KeyCommand(exports.KeyCmd.CLICK, key));
    }
    /**
     * Execute a "press" ("keydown") on the remote
     * @param {RcKeyCode} key
     */
    async press(key) {
        await this.send(new command_1.KeyCommand(exports.KeyCmd.PRESS, key));
    }
    /**
     * Execute a "release" ("keyup") on the remote
     * @param {RcKeyCode} key
     */
    async release(key) {
        await this.send(new command_1.KeyCommand(exports.KeyCmd.RELEASE, key));
    }
    /**
     * Execute a "long" press on the remote
     * @param {RcKeyCode} key
     */
    async longPress(key, ms = 1000) {
        await this.send(new command_1.KeyCommand(exports.KeyCmd.PRESS, key));
        await (0, delay_1.default)(ms);
        await this.send(new command_1.KeyCommand(exports.KeyCmd.RELEASE, key));
    }
    /**
     * Gets a new token from the Tizen device (if none exists).
     *
     * If a new token must be requested, expect to wait _at least_ thirty (30) seconds.
     * @param {NoConnectOption & {force?: boolean}} opts
     * @returns {Promise<string | undefined>}
     */
    async getToken({ noConnect = false, force = false } = {}) {
        if (!force) {
            if (__classPrivateFieldGet(this, _TizenRemote_token, "f")) {
                return __classPrivateFieldGet(this, _TizenRemote_token, "f");
            }
            const token = await this.readToken();
            if (token) {
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Read token from cache: %s', token);
                return token;
            }
        }
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Requesting new token; please wait...');
        // temporarily disable the "new token" listener, which can happen at any time.
        // if we don't do this, it'll fire twice.
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_offWs).call(this, exports.WsEvent.MESSAGE, __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_updateTokenListener));
        try {
            const res = await this.sendRequest(exports.constants.TOKEN_EVENT, new command_1.KeyCommand(exports.KeyCmd.CLICK, keys_1.Keys.HOME), { noConnect, noToken: true, timeout: __classPrivateFieldGet(this, _TizenRemote_tokenTimeout, "f") });
            if (isTokenMessage(res)) {
                const { token } = res.data;
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received message w/ token: %s', token);
                await this.writeToken(token);
                this.emit(exports.Event.TOKEN, token);
                return token;
            }
            if (!(await this.isTokenSupportedDevice())) {
                throw new Error(`The device does not support token or it could not get token; server responded with: ${format('%O', res)}`);
            }
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'The device may not support token as old model.');
            return;
        }
        finally {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onWs).call(this, exports.WsEvent.MESSAGE, __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_updateTokenListener), { context: this });
        }
    }
    /**
     * Send some text
     * @param {string} str
     */
    async text(str) {
        await this.send(new command_1.TextCommand(str));
    }
    /**
     * Connect to the Tizen web socket server.
     * @param {ConnectOptions} opts - Options
     * @returns {Promise<WebSocket>}
     */
    async connect({ noToken = false } = {}) {
        if (!__classPrivateFieldGet(this, _TizenRemote_token, "f") && !noToken) {
            let token = await this.readToken();
            if (token) {
                __classPrivateFieldSet(this, _TizenRemote_token, token, "f");
            }
        }
        else if (__classPrivateFieldGet(this, _TizenRemote_token, "f")) {
            await this.writeToken(__classPrivateFieldGet(this, _TizenRemote_token, "f"));
        }
        // the default behavior of pRetry is to use an exponential backoff, so
        // that's what we are using
        const ws = await (0, p_retry_1.default)((attempt) => {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Connecting to %s (attempt %d)...', __classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get), attempt);
            return /** @type {Promise<WebSocket>} */ (new Promise((resolve, reject) => {
                this.emit(exports.Event.CONNECTING);
                if (attempt > 1) {
                    this.emit(exports.Event.RETRY, attempt);
                }
                // The following two listeners would normally be handled by
                // `#onceWs`, but since we don't yet _have_ a `#ws` property,
                // we don't want to use them due to the complexity involved in
                // trying to fake it.
                /**
                 * Called if handshake fails.
                 *
                 * Must remove `WsEvent.ERROR` listener to avoid leaks.
                 * @param {Error} err
                 */
                const errListener = (err) => {
                    ws.removeListener(exports.WsEvent.OPEN, openListener);
                    reject(err);
                };
                /**
                 * Called if handshake succeeds
                 *
                 * **Must** remove `WsEvent.ERROR` listener to avoid leaks.
                 */
                const openListener = () => {
                    __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Connected to %s', __classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get));
                    ws.removeListener(exports.WsEvent.ERROR, errListener);
                    resolve(ws);
                };
                const ws = new ws_1.default(__classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get), {
                    handshakeTimeout: __classPrivateFieldGet(this, _TizenRemote_handshakeTimeout, "f"),
                    rejectUnauthorized: false,
                })
                    .once(exports.WsEvent.OPEN, openListener)
                    .once(exports.WsEvent.ERROR, errListener);
            }));
        }, {
            // note that if this function throws, no more retries will be attempted.
            onFailedAttempt: (err) => {
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Connection attempt %d (%d remain) failed: %s', err.attemptNumber, err.retriesLeft, err.message);
                if (!err.retriesLeft) {
                    return Promise.reject(new Error(`Cannot connect to ${__classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get)} in ${err.attemptNumber} attempt(s); giving up`));
                }
            },
            retries: __classPrivateFieldGet(this, _TizenRemote_handshakeRetries, "f"),
        });
        __classPrivateFieldSet(this, _TizenRemote_ws, ws, "f");
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onceWs).call(this, exports.WsEvent.CLOSE, __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_closeListener), { context: this });
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onWs).call(this, exports.WsEvent.MESSAGE, __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debugListener), { context: this });
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onWs).call(this, exports.WsEvent.MESSAGE, __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_updateTokenListener), { context: this });
        if (!__classPrivateFieldGet(this, _TizenRemote_token, "f") && !noToken) {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Requesting new token; waiting %d...', __classPrivateFieldGet(this, _TizenRemote_tokenTimeout, "f") / 1000);
            __classPrivateFieldSet(this, _TizenRemote_token, await this.getToken(), "f");
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received token: %s', __classPrivateFieldGet(this, _TizenRemote_token, "f"));
        }
        this.emit(exports.Event.CONNECT, ws);
        return ws;
    }
    /**
     * `true` if we have an active WS connection
     */
    get isConnected() {
        return Boolean(__classPrivateFieldGet(this, _TizenRemote_ws, "f")?.readyState === ws_1.default.OPEN);
    }
    /**
     * `true` if we are not connected to the server
     */
    get isDisconnected() {
        return Boolean(__classPrivateFieldGet(this, _TizenRemote_ws, "f")?.readyState === ws_1.default.CLOSED);
    }
    /**
     * `true` if we've issued a manual disconnection
     */
    get isDisconnecting() {
        return Boolean(__classPrivateFieldGet(this, _TizenRemote_ws, "f")?.readyState === ws_1.default.CLOSING);
    }
    /**
     * `true` if we are currently attempting to connect to the server.
     */
    get isConnecting() {
        return Boolean(__classPrivateFieldGet(this, _TizenRemote_ws, "f")?.readyState === ws_1.default.CONNECTING);
    }
    /**
     * Path to the token cache file, if any
     * @type {string|undefined}
     */
    get tokenCachePath() {
        return __classPrivateFieldGet(this, _TizenRemote_tokenCache, "f")?.id;
    }
    /**
     * Current token, if any
     * @type {string|undefined}
     */
    get token() {
        return __classPrivateFieldGet(this, _TizenRemote_token, "f");
    }
    /**
     * Disconnect from the WS server.
     *
     * If not connected, this method does nothing.  If disconnection
     * already in progress, the `Promise` will fulfill upon disconnection.
     * @returns {Promise<void>}
     */
    async disconnect() {
        try {
            return await new Promise((resolve, reject) => {
                // nothing to do!
                if (!__classPrivateFieldGet(this, _TizenRemote_ws, "f") || this.isDisconnected) {
                    resolve();
                    return;
                }
                // disconnecting already in progress; easiest to just
                // wait for our own event.
                if (this.isDisconnecting) {
                    this.once(exports.Event.DISCONNECT, () => {
                        resolve();
                    });
                    return;
                }
                this.emit(exports.Event.DISCONNECTING);
                // we may have a "close" listener for auto-reconnect, so
                // we need to remove it before attempting disconnection.
                const closeListeners = __classPrivateFieldGet(this, _TizenRemote_listeners, "f").get(exports.WsEvent.CLOSE);
                if (closeListeners) {
                    for (const listener of closeListeners) {
                        __classPrivateFieldGet(this, _TizenRemote_ws, "f").removeListener(exports.WsEvent.CLOSE, listener);
                    }
                    closeListeners.clear();
                }
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onceWs).call(this, exports.WsEvent.CLOSE, () => {
                    __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Closed connection to server %s', __classPrivateFieldGet(this, _TizenRemote_instances, "a", _TizenRemote_url_get));
                    this.emit(exports.Event.DISCONNECT);
                    resolve();
                });
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_onceWs).call(this, exports.WsEvent.ERROR, (err) => {
                    reject(err);
                });
                __classPrivateFieldGet(this, _TizenRemote_ws, "f").close();
            });
        }
        finally {
            // remove any listeners we may have created.
            for (const [event, listeners] of __classPrivateFieldGet(this, _TizenRemote_listeners, "f")) {
                for (const listener of listeners) {
                    __classPrivateFieldGet(this, _TizenRemote_ws, "f")?.removeListener(event, listener);
                }
            }
            __classPrivateFieldGet(this, _TizenRemote_listeners, "f").clear();
        }
    }
}
exports.TizenRemote = TizenRemote;
_TizenRemote_host = new WeakMap(), _TizenRemote_port = new WeakMap(), _TizenRemote_id = new WeakMap(), _TizenRemote_token = new WeakMap(), _TizenRemote_ssl = new WeakMap(), _TizenRemote_ws = new WeakMap(), _TizenRemote_handshakeRetries = new WeakMap(), _TizenRemote_autoReconnect = new WeakMap(), _TizenRemote_handshakeTimeout = new WeakMap(), _TizenRemote_debugger = new WeakMap(), _TizenRemote_tokenTimeout = new WeakMap(), _TizenRemote_listeners = new WeakMap(), _TizenRemote_tokenCache = new WeakMap(), _TizenRemote_tokenSupportCache = new WeakMap(), _TizenRemote_persistToken = new WeakMap(), _TizenRemote_strongbox = new WeakMap(), _TizenRemote_instances = new WeakSet(), _TizenRemote_debug = function _TizenRemote_debug(...args) {
    __classPrivateFieldGet(this, _TizenRemote_debugger, "f").call(this, format(...args));
}, _TizenRemote_url_get = function _TizenRemote_url_get() {
    const url = new URL(`${__classPrivateFieldGet(this, _TizenRemote_ssl, "f") ? 'wss' : 'ws'}://${__classPrivateFieldGet(this, _TizenRemote_host, "f")}:${__classPrivateFieldGet(this, _TizenRemote_port, "f")}${exports.constants.API_PATH_V2}`);
    url.searchParams.set('name', __classPrivateFieldGet(this, _TizenRemote_id, "f"));
    if (__classPrivateFieldGet(this, _TizenRemote_token, "f")) {
        url.searchParams.set('token', __classPrivateFieldGet(this, _TizenRemote_token, "f"));
    }
    return url;
}, _TizenRemote_getTokenCache = 
/**
 * Initializes the token cache; otherwise returns the existing cache.
 *
 * Aditionally, any future writes to the cache must be wrapped in the lock.
 * @returns {Promise<import('@appium/strongbox').Item<string>>}
 * @privateRemarks Do not call `#hasToken()` from here, as it will cause an infinite stack
 */
async function _TizenRemote_getTokenCache() {
    if (__classPrivateFieldGet(this, _TizenRemote_tokenCache, "f")) {
        return __classPrivateFieldGet(this, _TizenRemote_tokenCache, "f");
    }
    if (__classPrivateFieldGet(this, _TizenRemote_token, "f")) {
        __classPrivateFieldSet(this, _TizenRemote_tokenCache, await __classPrivateFieldGet(this, _TizenRemote_strongbox, "f").createItemWithValue(__classPrivateFieldGet(this, _TizenRemote_host, "f"), __classPrivateFieldGet(this, _TizenRemote_token, "f")), "f");
    }
    else {
        __classPrivateFieldSet(this, _TizenRemote_tokenCache, await __classPrivateFieldGet(this, _TizenRemote_strongbox, "f").createItem(__classPrivateFieldGet(this, _TizenRemote_host, "f")), "f");
        __classPrivateFieldSet(this, _TizenRemote_token, __classPrivateFieldGet(this, _TizenRemote_tokenCache, "f").value, "f");
    }
    return __classPrivateFieldGet(this, _TizenRemote_tokenCache, "f");
}, _TizenRemote_listenWs = function _TizenRemote_listenWs(event, listener, { context, once = false } = {}) {
    if (!__classPrivateFieldGet(this, _TizenRemote_ws, "f")) {
        throw new Error('Failed to establish the websocket connection to the TV device. The rcToken was invalid or might need to be refreshed.');
    }
    const method = once ? __classPrivateFieldGet(this, _TizenRemote_ws, "f").once : __classPrivateFieldGet(this, _TizenRemote_ws, "f").on;
    const listeners = __classPrivateFieldGet(this, _TizenRemote_listeners, "f").get(event) ?? new Set();
    __classPrivateFieldGet(this, _TizenRemote_listeners, "f").set(event, listeners);
    if (context) {
        /** @type {Listener} */
        let boundListener;
        if (once) {
            boundListener = /** @type {Listener} */ ((...args) => {
                try {
                    listener.apply(context, args);
                }
                finally {
                    // remove the listener if it's a one-time listener
                    listeners.delete(boundListener);
                }
            });
        }
        else {
            boundListener = /** @type {Listener} */ (listener.bind(context));
        }
        listeners.add(boundListener);
        method.call(__classPrivateFieldGet(this, _TizenRemote_ws, "f"), event, boundListener);
        return boundListener;
    }
    listeners.add(listener);
    method.call(__classPrivateFieldGet(this, _TizenRemote_ws, "f"), event, listener);
    return listener;
}, _TizenRemote_onWs = function _TizenRemote_onWs(event, listener, { context } = {}) {
    return __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_listenWs).call(this, event, listener, { context });
}, _TizenRemote_onceWs = function _TizenRemote_onceWs(event, listener, { context } = {}) {
    return __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_listenWs).call(this, event, listener, { context, once: true });
}, _TizenRemote_offWs = function _TizenRemote_offWs(event, listener) {
    if (__classPrivateFieldGet(this, _TizenRemote_ws, "f")) {
        let foundListener = Boolean(__classPrivateFieldGet(this, _TizenRemote_listeners, "f").get(event)?.has(listener));
        if (foundListener) {
            __classPrivateFieldGet(this, _TizenRemote_ws, "f").removeListener(event, listener);
            __classPrivateFieldGet(this, _TizenRemote_listeners, "f").get(event)?.delete(listener);
        }
    }
}, _TizenRemote_debugListener = function _TizenRemote_debugListener(data, isBinary) {
    if (isBinary) {
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received binary message: %o', data);
    }
    else {
        try {
            const resData = JSON.parse(data.toString());
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received message: %o', resData);
        }
        catch { }
    }
}, _TizenRemote_updateTokenListener = 
/**
 * Listener for unprompted token update msgs from the server.
 * @param {import('ws').RawData} data
 * @param {boolean} isBinary
 */
async function _TizenRemote_updateTokenListener(data, isBinary) {
    if (isBinary) {
        return;
    }
    try {
        const msg = JSON.parse(data.toString());
        if (isTokenMessage(msg)) {
            const { token } = msg.data;
            if (token !== __classPrivateFieldGet(this, _TizenRemote_token, "f")) {
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received updated token: %s', token);
                __classPrivateFieldSet(this, _TizenRemote_token, token, "f");
                await this.writeToken(token);
                this.emit(exports.Event.TOKEN, token);
            }
            else {
                __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Warning: received token update, but token (%s) is unchanged', __classPrivateFieldGet(this, _TizenRemote_token, "f"));
            }
        }
        else if (isCommandTimeout(msg)) {
            __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received ms.channel.timeOut message. The token (%s) might need a fresh one. ' +
                'Unset the token to start from a fresh token. Please complete the device paring if needed.', __classPrivateFieldGet(this, _TizenRemote_token, "f"));
            this.unsetToken();
        }
    }
    catch (err) {
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Warning: could not parse message: %s', err);
    }
}, _TizenRemote_closeListener = 
/**
 * This is the definition of a listener for the {@linkcode WsEvent#CLOSE} event
 * which handles unexpected disconnections.
 *
 * When listening, this method will be bound to this instance.
 *
 * Note: `reason` mostly seems to be an empty `Buffer`. If someone sees it actually
 * contain any information, please [tell us](https://github.com/headspinio/appium-tizen-tv-driver/issues/new).
 * @param {number} code - Disconnection code; see {@linkcode BadCode}
 * @param {Buffer} reason - Disconnection reason
 */
async function _TizenRemote_closeListener(code, reason) {
    this.emit(exports.Event.DISCONNECT, { code, reason });
    if (isKnownBadCode(code)) {
        __classPrivateFieldGet(this, _TizenRemote_instances, "m", _TizenRemote_debug).call(this, 'Received "%s" (%d)', exports.BadCode[code], code);
        if (__classPrivateFieldGet(this, _TizenRemote_autoReconnect, "f")) {
            try {
                await this.connect();
            }
            catch (err) {
                this.emit(exports.Event.ERROR, /** @type {Error} */ (err));
            }
        }
        else {
            this.emit(exports.Event.ERROR, new Error(`Socket disconnected; ${exports.BadCode[code]}: ${reason || '(no reason provided)'}`));
        }
    }
};
/**
 * A key of {@linkcode Keys}.
 * @typedef {keyof typeof Keys} Key
 * @group Utility
 */
/**
 * Types for event data emitted by a {@linkcode TizenRemote} instance.
 *
 * The keys of this type correspond to {@linkcode Event Events}.
 * @typedef TizenRemoteEventData
 * @property {WebSocket} connect - Emitted when connected to WS server
 * @property {void} connecting - Emitted when connecting to WS server
 * @property {Error} error - Emitted when an error occurs
 * @property {void|{code:number, reason:Buffer}} disconnect - Emitted when disconnected from WS server; `void` if disconnected manually
 * @property {void} disconnecting - Emitted when disconnecting manually
 * @property {number} retry - Emitted if retrying a connection
 * @property {string} token - Emitted when a new token is received
 * @property {string} sent - Emitted when a message has successfully been sent
 * @event
 */
/**
 * @typedef {import('strict-event-emitter-types').StrictEventEmitter<EventEmitter, TizenRemoteEventData>} TizenRemoteInstance
 * @group Utility
 */
/**
 * A named key constant as recognized by the Tizen remote WS server looks like this.
 * @typedef {import('type-fest').ValueOf<Keys>} RcKeyCode
 * @group Message Data
 */
/**
 * A "keypress" type event. Used by {@linkcode TizenRemoteCommandParams.DataOfCmd}.
 * @typedef {'Press' | 'Click' | 'Release'} KeyCommandType
 * @group Message Data
 */
/**
 * Potential value for {@linkcode TizenRemoteCommandParams.Cmd}.
 * @group Message Data
 * @typedef {import('type-fest').LiteralUnion<KeyCommandType, string>} TizenRemoteCommandParamsCmd
 */
/**
 * The potential values for {@linkcode TizenRemoteCommandParams.TypeOfRemote}.
 * @group Message Data
 * @typedef {'SendRemoteKey'|'SendInputString'} TizenRemoteCommandType
 */
/**
 * Internal object within {@linkcode TizenRemoteCommand}.
 * @template {TizenRemoteCommandParamsCmd} Cmd
 * @template {RcKeyCode | 'base64'} Data
 * @typedef TizenRemoteCommandParams
 * @property {Cmd} Cmd
 * @property {Data} DataOfCmd
 * @property {'false'} Option
 * @property {TizenRemoteCommandType} TypeOfRemote
 * @group Message Data
 */
/**
 * An object having a `noConnect` property. Used by various options
 * @typedef NoConnectOption
 * @property {boolean} [noConnect] - If `true`, do not automatically attempt to connect if disconnected
 * @group Utility
 */
/**
 * An object having a `noToken` property. Used by various options
 * @typedef NoTokenOption
 * @property {boolean} [noToken] - If `true`, do not automatically attempt to get a token if one is unset.
 * @group Utility
 */
/**
 * Options for {@linkcode TizenRemote.connect}.
 * @group Options
 * @typedef {NoTokenOption} ConnectOptions
 */
/**
 * Options for {@linkcode TizenRemote.send} and {@linkcode TizenRemote.sendRequest}.
 * @group Options
 * @typedef {NoTokenOption & NoConnectOption} SendOptions
 */
/**
 * Options for {@linkcode TizenRemote.getToken}.
 * @group Options
 * @typedef {NoConnectOption} GetTokenOptions
 */
/**
 * An object having a `timeout` property; used by various options.
 * @group Utility
 * @typedef TimeoutOption
 * @property {number} [timeout] - Timeout for the request (ms)
 */
/**
 * Options for {@linkcode TizenRemote.sendRequest}.
 * @group Options
 * @typedef {NoTokenOption & NoConnectOption & TimeoutOption} SendRequestOptions
 */
/**
 * @internal
 * @typedef NewTokenMessage
 * @property {typeof constants.TOKEN_EVENT} event
 * @property {WithToken} data
 */
/**
 * @internal
 * @typedef WithToken
 * @property {string} token
 */
/**
 * The shape of the on-disk token cache
 * @internal
 * @typedef {Record<string,WithToken>} TokenCache
 */
/**
 * @typedef {import('./types').TizenRemoteOptions} TizenRemoteOptions
 */
//# sourceMappingURL=tizen-remote.js.map