export { Keys };
/**
 * Codes received when a connection to a WSS fails.
 * @see https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1
 * @group Constants
 */
export const BadCode: {
    readonly 1002: "Protocol Error";
    readonly 1003: "Invalid Data Type";
    readonly 1005: "No Status";
    readonly 1006: "Abnormal Closure";
    readonly 1007: "Invalid Message Data Type";
    readonly 1008: "Policy Violation";
    readonly 1009: "Message Too Big";
    readonly 1010: "Mandatory Extension Missing";
    readonly 1011: "Unexpected Condition";
    readonly 1015: "TLS Handshake Failure";
};
export namespace constants {
    let API_PATH_V2: "/api/v2/channels/samsung.remote.control";
    let DEFAULT_HANDSHAKE_TIMEOUT: 1000;
    let DEFAULT_HANDSHAKE_RETRIES: 2;
    let DEFAULT_AUTO_RECONNECT: true;
    let DEFAULT_TOKEN_TIMEOUT: 40000;
    let DEFAULT_PORT: 8002;
    let DEFAULT_SSL: true;
    let DEFAULT_NAME: "Appium";
    let COMMAND_METHOD: "ms.remote.control";
    let COMMAND_TIMEOUT: "ms.channel.timeOut";
    let TOKEN_EVENT: "ms.channel.connect";
    let COMMAND_PARAMS_OPTION: "false";
    let COMMAND_PARAMS_TYPE_OF_REMOTE: "SendRemoteKey";
    let TOKEN_CACHE_BASENAME: "token-cache";
    let TOKEN_CACHE_LOCKFILE_NAME: "token-cache.lock";
    let DEFAULT_PERSIST_TOKEN: true;
    let NS: "tizen-remote";
}
export namespace Event {
    let CONNECT: "connect";
    let CONNECTING: "connecting";
    let DISCONNECT: "disconnect";
    let DISCONNECTING: "disconnecting";
    let ERROR: "error";
    let RETRY: "retry";
    let TOKEN: "token";
    let SENT: "sent";
}
export namespace KeyCmd {
    let PRESS: "Press";
    let CLICK: "Click";
    let RELEASE: "Release";
}
/**
 * *
 */
export type WsEvent = string;
export namespace WsEvent {
    let CONNECT_1: "connect";
    export { CONNECT_1 as CONNECT };
    export let CLOSE: "close";
    let ERROR_1: "error";
    export { ERROR_1 as ERROR };
    export let OPEN: "open";
    export let MESSAGE: "message";
}
declare const TizenRemote_base: new () => TizenRemoteInstance;
/**
 * Represents a connection to a Tizen web socket server.
 */
export class TizenRemote extends TizenRemote_base {
    /**
     * @param {string} host - IP or hostname of the Tizen device
     * @param {TizenRemoteOptions} [opts]
     */
    constructor(host: string, opts?: TizenRemoteOptions);
    /**
     * Just returns the client name (which is a base64-encoded string).
     */
    get base64Name(): string;
    /**
     * Computed URL of the Tizen device's websocket endpoint (as a string)
     */
    get url(): string;
    /**
     * Return True if the target device has 'TokenAuthSupport' param for the api/v2 endpoint.
     * No 'TokenAuthSupport' indicates the device does not require "token".
     * @returns {Promise<boolean>}
     */
    isTokenSupportedDevice(): Promise<boolean>;
    /**
     * Private. Accessible for testing
     * @param {any} jsonBody
     * @returns {'true'|'false'|undefined}
     */
    _getDeviceSupportsTokens(jsonBody: any): "true" | "false" | undefined;
    /**
     * Unsets token.
     *
     * If token cache persistence is enabled, this will remove it from the cache as well.
     */
    unsetToken(): Promise<void>;
    /**
     * Resolves `true` if a token is set or the cache contains a token
     * @returns {Promise<boolean>}
     */
    hasToken(): Promise<boolean>;
    /**
     * Reads token (if available) from the token cache in the filesystem
     *
     * If `#persistToken` is false, this will _always_ return `undefined`.
     * @returns {Promise<string|undefined>}
     */
    readToken(): Promise<string | undefined>;
    /**
     * Writes token to the token cache in the filesystem.
     *
     * If `#persistToken` is false, this will _never_ write to the cache.
     * @param {string} token
     * @returns {Promise<void>}
     */
    writeToken(token: string): Promise<void>;
    /**
     * Send JSON-serializable data to the Tizen web socket server.
     *
     * This is low-level, and you probably want something else.
     * @param {any} data
     * @param {NoConnectOption & NoTokenOption} opts
     * @returns {Promise<void>}
     */
    send(data: any, { noConnect, noToken }?: NoConnectOption & NoTokenOption): Promise<void>;
    /**
     * Send JSON-serializable data to the Tizen web socket server.
     *
     * This is low-level, and you probably want something else.
     * @template T
     * @param {string} channel
     * @param {any} data
     * @param {SendRequestOptions} opts
     * @returns {Promise<T>}
     */
    sendRequest<T>(channel: string, data: any, { noConnect, noToken, timeout }?: SendRequestOptions): Promise<T>;
    /**
     * Execute a "click" on the remote
     * @param {RcKeyCode} key
     */
    click(key: RcKeyCode): Promise<void>;
    /**
     * Execute a "press" ("keydown") on the remote
     * @param {RcKeyCode} key
     */
    press(key: RcKeyCode): Promise<void>;
    /**
     * Execute a "release" ("keyup") on the remote
     * @param {RcKeyCode} key
     */
    release(key: RcKeyCode): Promise<void>;
    /**
     * Execute a "long" press on the remote
     * @param {RcKeyCode} key
     */
    longPress(key: RcKeyCode, ms?: number): Promise<void>;
    /**
     * Gets a new token from the Tizen device (if none exists).
     *
     * If a new token must be requested, expect to wait _at least_ thirty (30) seconds.
     * @param {NoConnectOption & {force?: boolean}} opts
     * @returns {Promise<string | undefined>}
     */
    getToken({ noConnect, force }?: NoConnectOption & {
        force?: boolean;
    }): Promise<string | undefined>;
    /**
     * Send some text
     * @param {string} str
     */
    text(str: string): Promise<void>;
    /**
     * Connect to the Tizen web socket server.
     * @param {ConnectOptions} opts - Options
     * @returns {Promise<WebSocket>}
     */
    connect({ noToken }?: ConnectOptions): Promise<WebSocket>;
    /**
     * `true` if we have an active WS connection
     */
    get isConnected(): boolean;
    /**
     * `true` if we are not connected to the server
     */
    get isDisconnected(): boolean;
    /**
     * `true` if we've issued a manual disconnection
     */
    get isDisconnecting(): boolean;
    /**
     * `true` if we are currently attempting to connect to the server.
     */
    get isConnecting(): boolean;
    /**
     * Path to the token cache file, if any
     * @type {string|undefined}
     */
    get tokenCachePath(): string | undefined;
    /**
     * Current token, if any
     * @type {string|undefined}
     */
    get token(): string | undefined;
    /**
     * Disconnect from the WS server.
     *
     * If not connected, this method does nothing.  If disconnection
     * already in progress, the `Promise` will fulfill upon disconnection.
     * @returns {Promise<void>}
     */
    disconnect(): Promise<void>;
    #private;
}
/**
 * A key of {@linkcode Keys}.
 */
export type Key = keyof typeof Keys;
/**
 * Types for event data emitted by a {@linkcode TizenRemote} instance.
 *
 * The keys of this type correspond to {@linkcode Event Events}.
 */
export type TizenRemoteEventData = {
    /**
     * - Emitted when connected to WS server
     */
    connect: WebSocket;
    /**
     * - Emitted when connecting to WS server
     */
    connecting: void;
    /**
     * - Emitted when an error occurs
     */
    error: Error;
    /**
     * - Emitted when disconnected from WS server; `void` if disconnected manually
     */
    disconnect: void | {
        code: number;
        reason: Buffer;
    };
    /**
     * - Emitted when disconnecting manually
     */
    disconnecting: void;
    /**
     * - Emitted if retrying a connection
     */
    retry: number;
    /**
     * - Emitted when a new token is received
     */
    token: string;
    /**
     * - Emitted when a message has successfully been sent
     */
    sent: string;
};
export type TizenRemoteInstance = import("strict-event-emitter-types").StrictEventEmitter<EventEmitter, TizenRemoteEventData>;
/**
 * A named key constant as recognized by the Tizen remote WS server looks like this.
 */
export type RcKeyCode = import("type-fest").ValueOf<{
    readonly 0: "KEY_0";
    readonly 1: "KEY_1";
    readonly 2: "KEY_2";
    readonly 3: "KEY_3";
    readonly 4: "KEY_4";
    readonly 5: "KEY_5";
    readonly 6: "KEY_6";
    readonly 7: "KEY_7";
    readonly 8: "KEY_8";
    readonly 9: "KEY_9";
    readonly 11: "KEY_11";
    readonly 12: "KEY_12";
    readonly '16_9': "KEY_16_9";
    readonly '4_3': "KEY_4_3";
    readonly '3SPEED': "KEY_3SPEED";
    readonly AD: "KEY_AD";
    readonly ADDDEL: "KEY_ADDDEL";
    readonly ALT_MHP: "KEY_ALT_MHP";
    readonly ANGLE: "KEY_ANGLE";
    readonly ANTENA: "KEY_ANTENA";
    readonly ANYNET: "KEY_ANYNET";
    readonly ANYVIEW: "KEY_ANYVIEW";
    readonly APP_LIST: "KEY_APP_LIST";
    readonly ASPECT: "KEY_ASPECT";
    readonly AUTO_ARC_ANTENNA_AIR: "KEY_AUTO_ARC_ANTENNA_AIR";
    readonly AUTO_ARC_ANTENNA_CABLE: "KEY_AUTO_ARC_ANTENNA_CABLE";
    readonly AUTO_ARC_ANTENNA_SATELLITE: "KEY_AUTO_ARC_ANTENNA_SATELLITE";
    readonly AUTO_ARC_ANYNET_AUTO_START: "KEY_AUTO_ARC_ANYNET_AUTO_START";
    readonly AUTO_ARC_ANYNET_MODE_OK: "KEY_AUTO_ARC_ANYNET_MODE_OK";
    readonly AUTO_ARC_AUTOCOLOR_FAIL: "KEY_AUTO_ARC_AUTOCOLOR_FAIL";
    readonly AUTO_ARC_AUTOCOLOR_SUCCESS: "KEY_AUTO_ARC_AUTOCOLOR_SUCCESS";
    readonly AUTO_ARC_C_FORCE_AGING: "KEY_AUTO_ARC_C_FORCE_AGING";
    readonly AUTO_ARC_CAPTION_ENG: "KEY_AUTO_ARC_CAPTION_ENG";
    readonly AUTO_ARC_CAPTION_KOR: "KEY_AUTO_ARC_CAPTION_KOR";
    readonly AUTO_ARC_CAPTION_OFF: "KEY_AUTO_ARC_CAPTION_OFF";
    readonly AUTO_ARC_CAPTION_ON: "KEY_AUTO_ARC_CAPTION_ON";
    readonly AUTO_ARC_JACK_IDENT: "KEY_AUTO_ARC_JACK_IDENT";
    readonly AUTO_ARC_LNA_OFF: "KEY_AUTO_ARC_LNA_OFF";
    readonly AUTO_ARC_LNA_ON: "KEY_AUTO_ARC_LNA_ON";
    readonly AUTO_ARC_PIP_CH_CHANGE: "KEY_AUTO_ARC_PIP_CH_CHANGE";
    readonly AUTO_ARC_PIP_DOUBLE: "KEY_AUTO_ARC_PIP_DOUBLE";
    readonly AUTO_ARC_PIP_LARGE: "KEY_AUTO_ARC_PIP_LARGE";
    readonly AUTO_ARC_PIP_LEFT_BOTTOM: "KEY_AUTO_ARC_PIP_LEFT_BOTTOM";
    readonly AUTO_ARC_PIP_LEFT_TOP: "KEY_AUTO_ARC_PIP_LEFT_TOP";
    readonly AUTO_ARC_PIP_RIGHT_BOTTOM: "KEY_AUTO_ARC_PIP_RIGHT_BOTTOM";
    readonly AUTO_ARC_PIP_RIGHT_TOP: "KEY_AUTO_ARC_PIP_RIGHT_TOP";
    readonly AUTO_ARC_PIP_SMALL: "KEY_AUTO_ARC_PIP_SMALL";
    readonly AUTO_ARC_PIP_SOURCE_CHANGE: "KEY_AUTO_ARC_PIP_SOURCE_CHANGE";
    readonly AUTO_ARC_PIP_WIDE: "KEY_AUTO_ARC_PIP_WIDE";
    readonly AUTO_ARC_RESET: "KEY_AUTO_ARC_RESET";
    readonly AUTO_ARC_USBJACK_INSPECT: "KEY_AUTO_ARC_USBJACK_INSPECT";
    readonly AUTO_FORMAT: "KEY_AUTO_FORMAT";
    readonly AUTO_PROGRAM: "KEY_AUTO_PROGRAM";
    readonly AV1: "KEY_AV1";
    readonly AV2: "KEY_AV2";
    readonly AV3: "KEY_AV3";
    readonly BACK_MHP: "KEY_BACK_MHP";
    readonly BOOKMARK: "KEY_BOOKMARK";
    readonly CALLER_ID: "KEY_CALLER_ID";
    readonly CAPTION: "KEY_CAPTION";
    readonly CATV_MODE: "KEY_CATV_MODE";
    readonly CH_LIST: "KEY_CH_LIST";
    readonly CHDOWN: "KEY_CHDOWN";
    readonly CHUP: "KEY_CHUP";
    readonly CLEAR: "KEY_CLEAR";
    readonly CLOCK_DISPLAY: "KEY_CLOCK_DISPLAY";
    readonly COMPONENT1: "KEY_COMPONENT1";
    readonly COMPONENT2: "KEY_COMPONENT2";
    readonly CONTENTS: "KEY_CONTENTS";
    readonly CONVERGENCE: "KEY_CONVERGENCE";
    readonly CONVERT_AUDIO_MAINSUB: "KEY_CONVERT_AUDIO_MAINSUB";
    readonly CUSTOM: "KEY_CUSTOM";
    readonly CYAN: "KEY_CYAN";
    readonly DEVICE_CONNECT: "KEY_DEVICE_CONNECT";
    readonly DISC_MENU: "KEY_DISC_MENU";
    readonly DMA: "KEY_DMA";
    readonly DNET: "KEY_DNET";
    readonly DNIe: "KEY_DNIe";
    readonly DNSe: "KEY_DNSe";
    readonly DOOR: "KEY_DOOR";
    readonly DOWN: "KEY_DOWN";
    readonly DSS_MODE: "KEY_DSS_MODE";
    readonly DTV: "KEY_DTV";
    readonly DTV_LINK: "KEY_DTV_LINK";
    readonly DTV_SIGNAL: "KEY_DTV_SIGNAL";
    readonly DVD_MODE: "KEY_DVD_MODE";
    readonly DVI: "KEY_DVI";
    readonly DVR: "KEY_DVR";
    readonly DVR_MENU: "KEY_DVR_MENU";
    readonly DYNAMIC: "KEY_DYNAMIC";
    readonly ENTER: "KEY_ENTER";
    readonly ENTERTAINMENT: "KEY_ENTERTAINMENT";
    readonly ESAVING: "KEY_ESAVING";
    readonly EXIT: "KEY_EXIT";
    readonly EXT1: "KEY_EXT1";
    readonly EXT10: "KEY_EXT10";
    readonly EXT11: "KEY_EXT11";
    readonly EXT12: "KEY_EXT12";
    readonly EXT13: "KEY_EXT13";
    readonly EXT14: "KEY_EXT14";
    readonly EXT15: "KEY_EXT15";
    readonly EXT16: "KEY_EXT16";
    readonly EXT17: "KEY_EXT17";
    readonly EXT18: "KEY_EXT18";
    readonly EXT19: "KEY_EXT19";
    readonly EXT2: "KEY_EXT2";
    readonly EXT20: "KEY_EXT20";
    readonly EXT21: "KEY_EXT21";
    readonly EXT22: "KEY_EXT22";
    readonly EXT23: "KEY_EXT23";
    readonly EXT24: "KEY_EXT24";
    readonly EXT25: "KEY_EXT25";
    readonly EXT26: "KEY_EXT26";
    readonly EXT27: "KEY_EXT27";
    readonly EXT28: "KEY_EXT28";
    readonly EXT29: "KEY_EXT29";
    readonly EXT3: "KEY_EXT3";
    readonly EXT30: "KEY_EXT30";
    readonly EXT31: "KEY_EXT31";
    readonly EXT32: "KEY_EXT32";
    readonly EXT33: "KEY_EXT33";
    readonly EXT34: "KEY_EXT34";
    readonly EXT35: "KEY_EXT35";
    readonly EXT36: "KEY_EXT36";
    readonly EXT37: "KEY_EXT37";
    readonly EXT38: "KEY_EXT38";
    readonly EXT39: "KEY_EXT39";
    readonly EXT4: "KEY_EXT4";
    readonly EXT40: "KEY_EXT40";
    readonly EXT41: "KEY_EXT41";
    readonly EXT5: "KEY_EXT5";
    readonly EXT6: "KEY_EXT6";
    readonly EXT7: "KEY_EXT7";
    readonly EXT8: "KEY_EXT8";
    readonly EXT9: "KEY_EXT9";
    readonly FACTORY: "KEY_FACTORY";
    readonly FAVCH: "KEY_FAVCH";
    readonly FF: "KEY_FF";
    readonly FF_: "KEY_FF_";
    readonly FM_RADIO: "KEY_FM_RADIO";
    readonly GAME: "KEY_GAME";
    readonly GREEN: "KEY_GREEN";
    readonly GUIDE: "KEY_GUIDE";
    readonly HDMI: "KEY_HDMI";
    readonly HDMI1: "KEY_HDMI1";
    readonly HDMI2: "KEY_HDMI2";
    readonly HDMI3: "KEY_HDMI3";
    readonly HDMI4: "KEY_HDMI4";
    readonly HELP: "KEY_HELP";
    readonly HOME: "KEY_HOME";
    readonly ID_INPUT: "KEY_ID_INPUT";
    readonly ID_SETUP: "KEY_ID_SETUP";
    readonly INFO: "KEY_INFO";
    readonly INSTANT_REPLAY: "KEY_INSTANT_REPLAY";
    readonly LEFT: "KEY_LEFT";
    readonly LINK: "KEY_LINK";
    readonly LIVE: "KEY_LIVE";
    readonly MAGIC_BRIGHT: "KEY_MAGIC_BRIGHT";
    readonly MAGIC_CHANNEL: "KEY_MAGIC_CHANNEL";
    readonly MDC: "KEY_MDC";
    readonly MENU: "KEY_MENU";
    readonly MIC: "KEY_MIC";
    readonly MORE: "KEY_MORE";
    readonly MOVIE1: "KEY_MOVIE1";
    readonly MS: "KEY_MS";
    readonly MTS: "KEY_MTS";
    readonly MUTE: "KEY_MUTE";
    readonly NINE_SEPERATE: "KEY_NINE_SEPERATE";
    readonly OPEN: "KEY_OPEN";
    readonly PANNEL_CHDOWN: "KEY_PANNEL_CHDOWN";
    readonly PANNEL_CHUP: "KEY_PANNEL_CHUP";
    readonly PANNEL_ENTER: "KEY_PANNEL_ENTER";
    readonly PANNEL_MENU: "KEY_PANNEL_MENU";
    readonly PANNEL_POWER: "KEY_PANNEL_POWER";
    readonly PANNEL_SOURCE: "KEY_PANNEL_SOURCE";
    readonly PANNEL_VOLDOW: "KEY_PANNEL_VOLDOW";
    readonly PANNEL_VOLUP: "KEY_PANNEL_VOLUP";
    readonly PANORAMA: "KEY_PANORAMA";
    readonly PAUSE: "KEY_PAUSE";
    readonly PCMODE: "KEY_PCMODE";
    readonly PERPECT_FOCUS: "KEY_PERPECT_FOCUS";
    readonly PICTURE_SIZE: "KEY_PICTURE_SIZE";
    readonly PIP_CHDOWN: "KEY_PIP_CHDOWN";
    readonly PIP_CHUP: "KEY_PIP_CHUP";
    readonly PIP_ONOFF: "KEY_PIP_ONOFF";
    readonly PIP_SCAN: "KEY_PIP_SCAN";
    readonly PIP_SIZE: "KEY_PIP_SIZE";
    readonly PIP_SWAP: "KEY_PIP_SWAP";
    readonly PLAY: "KEY_PLAY";
    readonly PLUS100: "KEY_PLUS100";
    readonly PMODE: "KEY_PMODE";
    readonly POWER: "KEY_POWER";
    readonly POWEROFF: "KEY_POWEROFF";
    readonly POWERON: "KEY_POWERON";
    readonly PRECH: "KEY_PRECH";
    readonly PRINT: "KEY_PRINT";
    readonly PROGRAM: "KEY_PROGRAM";
    readonly QUICK_REPLAY: "KEY_QUICK_REPLAY";
    readonly REC: "KEY_REC";
    readonly RED: "KEY_RED";
    readonly REPEAT: "KEY_REPEAT";
    readonly RESERVED1: "KEY_RESERVED1";
    readonly RETURN: "KEY_RETURN";
    readonly REWIND: "KEY_REWIND";
    readonly REWIND_: "KEY_REWIND_";
    readonly RIGHT: "KEY_RIGHT";
    readonly RSS: "KEY_RSS";
    readonly RSURF: "KEY_RSURF";
    readonly SCALE: "KEY_SCALE";
    readonly SEFFECT: "KEY_SEFFECT";
    readonly SETUP_CLOCK_TIMER: "KEY_SETUP_CLOCK_TIMER";
    readonly SLEEP: "KEY_SLEEP";
    readonly SOURCE: "KEY_SOURCE";
    readonly SRS: "KEY_SRS";
    readonly STANDARD: "KEY_STANDARD";
    readonly STB_MODE: "KEY_STB_MODE";
    readonly STILL_PICTURE: "KEY_STILL_PICTURE";
    readonly STOP: "KEY_STOP";
    readonly SUB_TITLE: "KEY_SUB_TITLE";
    readonly SVIDEO1: "KEY_SVIDEO1";
    readonly SVIDEO2: "KEY_SVIDEO2";
    readonly SVIDEO3: "KEY_SVIDEO3";
    readonly TOOLS: "KEY_TOOLS";
    readonly TOPMENU: "KEY_TOPMENU";
    readonly TTX_MIX: "KEY_TTX_MIX";
    readonly TTX_SUBFACE: "KEY_TTX_SUBFACE";
    readonly TURBO: "KEY_TURBO";
    readonly TV: "KEY_TV";
    readonly TV_MODE: "KEY_TV_MODE";
    readonly UP: "KEY_UP";
    readonly VCHIP: "KEY_VCHIP";
    readonly VCR_MODE: "KEY_VCR_MODE";
    readonly VOLDOWN: "KEY_VOLDOWN";
    readonly VOLUP: "KEY_VOLUP";
    readonly W_LINK: "KEY_W_LINK";
    readonly WHEEL_LEFT: "KEY_WHEEL_LEFT";
    readonly WHEEL_RIGHT: "KEY_WHEEL_RIGHT";
    readonly YELLOW: "KEY_YELLOW";
    readonly ZOOM_IN: "KEY_ZOOM_IN";
    readonly ZOOM_MOVE: "KEY_ZOOM_MOVE";
    readonly ZOOM_OUT: "KEY_ZOOM_OUT";
    readonly ZOOM1: "KEY_ZOOM1";
    readonly ZOOM2: "KEY_ZOOM2";
}>;
/**
 * A "keypress" type event. Used by {@linkcode TizenRemoteCommandParams.DataOfCmd}.
 */
export type KeyCommandType = "Press" | "Click" | "Release";
/**
 * Potential value for {@linkcode TizenRemoteCommandParams.Cmd}.
 */
export type TizenRemoteCommandParamsCmd = import("type-fest").LiteralUnion<KeyCommandType, string>;
/**
 * The potential values for {@linkcode TizenRemoteCommandParams.TypeOfRemote}.
 */
export type TizenRemoteCommandType = "SendRemoteKey" | "SendInputString";
/**
 * Internal object within {@linkcode TizenRemoteCommand}.
 */
export type TizenRemoteCommandParams<Cmd extends TizenRemoteCommandParamsCmd, Data extends RcKeyCode | "base64"> = {
    Cmd: Cmd;
    DataOfCmd: Data;
    Option: "false";
    TypeOfRemote: TizenRemoteCommandType;
};
/**
 * An object having a `noConnect` property. Used by various options
 */
export type NoConnectOption = {
    /**
     * - If `true`, do not automatically attempt to connect if disconnected
     */
    noConnect?: boolean | undefined;
};
/**
 * An object having a `noToken` property. Used by various options
 */
export type NoTokenOption = {
    /**
     * - If `true`, do not automatically attempt to get a token if one is unset.
     */
    noToken?: boolean | undefined;
};
/**
 * Options for {@linkcode TizenRemote.connect}.
 */
export type ConnectOptions = NoTokenOption;
/**
 * Options for {@linkcode TizenRemote.send} and {@linkcode TizenRemote.sendRequest}.
 */
export type SendOptions = NoTokenOption & NoConnectOption;
/**
 * Options for {@linkcode TizenRemote.getToken}.
 */
export type GetTokenOptions = NoConnectOption;
/**
 * An object having a `timeout` property; used by various options.
 */
export type TimeoutOption = {
    /**
     * - Timeout for the request (ms)
     */
    timeout?: number | undefined;
};
/**
 * Options for {@linkcode TizenRemote.sendRequest}.
 */
export type SendRequestOptions = NoTokenOption & NoConnectOption & TimeoutOption;
export type NewTokenMessage = {
    event: typeof constants.TOKEN_EVENT;
    data: WithToken;
};
export type WithToken = {
    token: string;
};
/**
 * The shape of the on-disk token cache
 */
export type TokenCache = Record<string, WithToken>;
export type TizenRemoteOptions = import("./types").TizenRemoteOptions;
import { Keys } from './keys';
import WebSocket from 'ws';
import { EventEmitter } from 'node:events';
//# sourceMappingURL=tizen-remote.d.ts.map