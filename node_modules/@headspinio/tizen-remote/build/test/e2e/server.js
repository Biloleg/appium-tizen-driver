"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TestWSServer_instances, _TestWSServer_keepAliveTimeout, _TestWSServer_keepAliveInterval, _TestWSServer_resetKeepAliveInterval, _TestWSServer_stopKeepAliveInterval;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestWSServer = void 0;
const node_util_1 = require("node:util");
const ws_1 = require("ws");
const node_url_1 = require("node:url");
const debug_1 = __importDefault(require("debug"));
const delay_1 = __importDefault(require("delay"));
const debug = (0, debug_1.default)('tizen-remote:test:e2e:server');
/**
 * @type {WeakMap<import('ws').WebSocket,boolean>}
 */
const heartbeats = new WeakMap();
const KEEP_ALIVE_TIMEOUT = 5000;
/**
 * Websocket server for E2E API testing
 */
class TestWSServer extends ws_1.WebSocketServer {
    /**
     * @param {import('ws').ServerOptions & {keepaliveTimeout?: number, keepalive?: boolean}} opts
     */
    constructor(opts) {
        super(opts);
        _TestWSServer_instances.add(this);
        _TestWSServer_keepAliveTimeout.set(this, KEEP_ALIVE_TIMEOUT);
        /** @type {NodeJS.Timer|undefined} */
        _TestWSServer_keepAliveInterval.set(this, void 0);
        this.tokens = new Map();
        if (opts.keepalive !== false) {
            this.on('connection', (ws, req) => {
                heartbeats.set(ws, true);
                ws.on('pong', () => {
                    debug('Client at %s:%d is alive', req.socket.remoteAddress, req.socket.remotePort);
                    heartbeats.set(ws, true);
                });
            }).on('close', () => {
                __classPrivateFieldGet(this, _TestWSServer_instances, "m", _TestWSServer_stopKeepAliveInterval).call(this);
            });
            __classPrivateFieldSet(this, _TestWSServer_keepAliveTimeout, opts.keepaliveTimeout ?? KEEP_ALIVE_TIMEOUT, "f");
            __classPrivateFieldGet(this, _TestWSServer_instances, "m", _TestWSServer_resetKeepAliveInterval).call(this);
        }
        this.on('listening', () => {
            // likely not a unix pipe, so we get an `AddressInfo` object back
            const { address, port } = /** @type {import('node:net').AddressInfo} */ (this.address());
            debug('Server started listening on %s:%d', address, port);
            this.once('close', () => {
                debug('Server stopped listening on %s:%d', address, port);
            });
            this.on('connection', (ws, req) => {
                debug('Connection from %s:%d', req.socket.remoteAddress, req.socket.remotePort);
                // unsure of a better way to extract the searchParams from the request URL
                const clientName = (req.url
                    ? new URLSearchParams(/** @type {string} */ ((0, node_url_1.parse)(req.url).query)).get('name')
                    : undefined) ?? '(unknown)';
                ws.once('message', async (data) => {
                    /** @type {any} */
                    let payload;
                    try {
                        payload = JSON.parse(data.toString());
                    }
                    catch {
                        payload = '(invalid JSON)';
                    }
                    debug('Message from %s:%d: %O', req.socket.remoteAddress, req.socket.remotePort, payload);
                    this.tokens.set(clientName, `token-${clientName}`);
                    await (0, delay_1.default)(20);
                    const response = {
                        data: {
                            token: this.tokens.get(clientName),
                        },
                        event: 'ms.channel.connect',
                    };
                    if (req.socket.writable) {
                        debug('Sending response to %s:%d: %O', req.socket.remoteAddress, req.socket.remotePort, response);
                        ws.send(JSON.stringify(response));
                    }
                    else {
                        debug('Socket %s:%d hung up before we could send a response', req.socket.remoteAddress, req.socket.remotePort);
                    }
                });
            });
        });
    }
    /**
     *
     * @param {import('type-fest').JsonValue} data
     */
    broadcast(data) {
        for (const ws of this.clients) {
            ws.send(JSON.stringify(data));
        }
    }
    /**
     * Disconnects all connected clients and stops the server
     */
    async stop() {
        for (const ws of this.clients) {
            ws.close();
        }
        try {
            await (0, node_util_1.promisify)(this.close).call(this);
        }
        catch {
            // might already be closed
        }
    }
}
exports.TestWSServer = TestWSServer;
_TestWSServer_keepAliveTimeout = new WeakMap(), _TestWSServer_keepAliveInterval = new WeakMap(), _TestWSServer_instances = new WeakSet(), _TestWSServer_resetKeepAliveInterval = function _TestWSServer_resetKeepAliveInterval() {
    __classPrivateFieldGet(this, _TestWSServer_instances, "m", _TestWSServer_stopKeepAliveInterval).call(this);
    __classPrivateFieldSet(this, _TestWSServer_keepAliveInterval, setInterval(() => {
        for (const conn of this.clients) {
            if (!heartbeats.get(conn)) {
                conn.terminate();
                return;
            }
            heartbeats.set(conn, false);
            // eslint-disable-next-line promise/prefer-await-to-callbacks
            conn.ping((/** @type {any} */ err) => {
                this.emit('client-disconnect', { ws: conn, err });
            });
        }
    }, __classPrivateFieldGet(this, _TestWSServer_keepAliveTimeout, "f")), "f");
}, _TestWSServer_stopKeepAliveInterval = function _TestWSServer_stopKeepAliveInterval() {
    clearInterval(__classPrivateFieldGet(this, _TestWSServer_keepAliveInterval, "f"));
};
//# sourceMappingURL=server.js.map